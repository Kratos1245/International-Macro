clear
tic

%%%%%%%%%%%%%%%%%%
%%% PARAMETERS %%%
%%%%%%%%%%%%%%%%%%
beta = 0.96; %discount factor
sigma = 2; %inverse of intertemporal elasticity
h = [0.01;1]; %labor
A = [0.9;1.1]; %TFP shocks
P_h = [0.8 0.2;0.2 0.8]; %transition matrix for labor
P_A = [0.9 0.1;0.1 0.9]; %transition matrix for TFP
bc = 0; %borrowing constraint
delta = 1; %capital depreciation
alpha = 1/3; %capital share
N = 300; %number of iterations
T = 1000; %number of simulation periods
M = 1000; %number of agents


%%%%%%%%%%
%%% SS %%%
%%%%%%%%%%
P_A_SS = P_A^1000; %stationary distribution of TFP
A_SS = P_A_SS(1,:)*A; %SS TFP
P_h_SS = P_h^1000; %stationary distribution of labor
h_SS = P_h_SS(1,:)*h; %SS labor
K_SS = h_SS*((1/beta-1+delta)/alpha/A_SS)^(1/(alpha-1)); %capital in Ramsey SS 


%%%%%%%%%%%%
%%% GRID %%%
%%%%%%%%%%%%
n_a = 50; %number of elements on grid for assets
n_K = 50; %number of elements on grid for capital
a_min = bc;
a_max = 10*K_SS;
K_min = 1.5*K_SS;
K_max = 3*K_SS;
g = (0:1/(n_a-1):1)';
a = a_min+(a_max-a_min)*g.^3; %grid of wealth
gg = (0:1/(n_K-1):1)';
K = K_min+(K_max-K_min)*gg; %grid of capital 
S = [kron(a,ones(4*n_K,1)) repmat(kron(h,ones(2*n_K,1)),n_a,1) repmat(kron(K,ones(2,1)),2*n_a,1) repmat(A  ,n_a*2*n_K,1)]; %state space
n_s = size(S,1); %number of elements on grid
S_n = [repmat(kron([1;2],ones(2*n_K,1)),n_a,1) repmat([1;2],n_a*2*n_K,1)]; %numbers of shocks


%%%%%%%%%%%%%
%%% GUESS %%%
%%%%%%%%%%%%%
b_ols = [0;1;0;1];
R_2 = 0; 
while R_2 < 0.99
H = [exp(b_ols(1)) b_ols(2); exp(b_ols(3)) b_ols(4)]; 
K_f = H(S_n(:,2),1).*S(:,3).^H(S_n(:,2),2); %future capital
[~, ind_K] = min(abs(repmat(K_f,1,n_K)-repmat(K',n_s,1)),[],2); %number of future K
J = [2*ind_K-1 2*ind_K 2*n_K+2*ind_K-1 2*n_K+2*ind_K]; %potential future states
P = zeros(n_s,4*n_K);
for i = 1:n_s
    P(i,J(i,1:2)) = P_h(S_n(i,1),1)*P_A(S_n(i,2),:);
    P(i,J(i,3:4)) = P_h(S_n(i,1),2)*P_A(S_n(i,2),:);
end
R = 1-delta+alpha*S(:,4).*(h_SS./S(:,3)).^(alpha-1); %capital rent
W = (1-alpha)*S(:,4).*(S(:,3)./h_SS).^alpha; %wage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SOLVING FOR VALUE FUNCTION %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c = repmat(R.*S(:,1)+W.*S(:,2),1,n_a)-repmat(a',n_s,1); %Используем бюджетное ограничение и матрицу S, в которой у нас 
%записаны все переменные состояния для каждого состояния. Не забываем, что по столбцам у нас должны вычитаться будущие
%значения сбережений, которые выбирает потребитель. Первое слагаемое у нас не зависит от будущих сбережений, поэтому мы его
%просто растягиваем на нужое количество столбцов. Второе слагаемое (вычитаемое) как раз и является будущим сбережением. Поэтому 
%мы создаем матрицу из повторяющихся строчек, в которых стоят все значения сбережений (наша решетка для сбережений).
c = max(c,0); %consumption as function of a,a'
U = (c.^(1-sigma)-1)/(1-sigma); %utility on grid
V = zeros(n_s,1); %initial guess
for t = 1:N
    V_old = V;
    [V, I] = max(U+beta*P*reshape(V,4*n_K,n_a),[],2); %Bellman equation. Здесь как раз то, что мы обсудили. Нам нужно прибавить мат.
    %ожидание value function. Для этого используем переходну матрицу P и reshaped столбец V. 
    error = max(abs((V-V_old)./V_old)); %Находим отклонение старой value function от новой. Если отклонение маленькое, то мы сошлись 
    %к оптимальной value function. В принципе N=300 итераций должно быть достаточно, чтобы сойтись. Но можно модифицировать этот цикл, 
    %как мы делалали раньше, чтобы итерации шли ровно до того момента, как рассотояние между новой и старой value function не уменьшится
    %до заданного значения.
end
Savings = a(I); %I - это вектор-столбец размерности n_s c номерами оптимальных будущих сбережений. a(I) нам дает вектор-столбец размерности n_s
%со значениеми оптимальных будущих сбережений.


%%%%%%%%%%%%%%%%%%%
%%% SIMULATIONS %%%
%%%%%%%%%%%%%%%%%%%
%Для удобства симуляций мы сейчас будем работать не с конкретными значениями наших переменных состояния, а с их номерами на решетке.
tfp_n(1,1) = 1; %Для tfp у нас два номера: 1 - это низкая производительность, 2 - высокая. зададим начальный урвоень производительности как низкий.
emp_n(:,1) = randi(2,M,1); %Для труда у нас тоже только 2 значения, но труд - индивидуальная переменная, т.е. для каждого д/х значение свое.
%Поэтому изначально мы случайным образом припишем каждому д/х либо номер 1, либо номер 2. Получим вектор столбец размерности M(количество д/х).
cap_n(1,1) = n_K/2; %Случайно зададим некоторый средний номер для капитала.
assets_n(:,1) = randi(n_a,M,1); %Также случайно зададим номера для сбережений для каждого д/х. Всего номеров n_a. Получим вектор столбец размерности M.
state = zeros(M,T); %Основа нашей концепции - расчет будущего капитала с использованием market clearing для капитала, т.е. капитал будущего периода
%равен интегралу сбережений на будущий период по континууму агентов (в нашем случае среднее среди 1000 агентов). Для этого нам необходимо знать, в каком
%состоянии находится каждый агент (д/х). В эту матрицу мы будем записывать номер состояния всех агентов в каждый период симуляции, который соответсвует 
%номеру состояния в матрице S.
for t = 1:T
    state(:,t) = tfp_n(1,t)+2*(cap_n(1,t)-1)+2*n_K*(emp_n(:,t)-1)+4*n_K*(assets_n(:,t)-1); %current state of agents; эта формула не сразу очевидна;
    %Чтобы ее понять, нужно посмотреть на матрицу переменных состояния S (она была на доске). Начнем с последнего слагаемого: если у текущего агента
    %номер сбережений m, то нам нужно пропустить в матрице S первые m-1 блоков, которые соотвествуют номерам сбережений от 1 до (m-1). В каждом таком блоке 
    %4*n_K строчек, соотвественно номер состояния сразу увеличивается на это число. Далее 3е слагаемое: мы уже находимся в нужном нам блоке по сбережениям,
    %необходимо перейти в один из двух блоков по труду. Второе слагаемое - переходим в нужный блок по капиталу. Первое слагаемое - определяет окончательный 
    %номер, в зависимости от того, какой уровень производительности сейчас в экономике.
    assets_n(:,t+1) = I(state(:,t)); %evolution of agents' wealth; Теперь, зная номер состояния, в котором находится каждый из агентов, мы можем посчитать
    %оптимальный уровень сбережений будущего периода. I(state(:,t)) нам даст вектор столбец размерности M с номерами оптимальных сбережений будущего периода.
    capital = mean(a(assets_n(:,t+1))); %Считаем капитал будущего периода. Для этого нам надо перейти уже к реальным значениям сбережений будущего периода.
    %a(assets_n(:,t+1)) позволяет нам получить вектор значений сбережений будущего периода. Находим среднее.
    [~, cap_n(1,t+1)] = min(abs(capital-K')); %number of future K; Среднее, которое мы почитали на предыдущем шаге, не обязано совпадать с каким либо элементом
    %на нашей решетке для капитала. Поэтому надо найти ближайшее значение капитала, которое есть на нашей решетке.
    
    %Далее нам нужно задать закон изменения производительности и занятости.
    %С производительность попроще - она едина для всех агентов.
    %Наш выбор будет основан на следующей теореме из тервера:
    %Независимо от того, как распределен x, функция распределения f(x) имеет равномерное распределение на отрезке [0;1] (Дима показывал это на одной из лекций, поищите).
    x = rand(1,1); %evolution of TFP number; Берем случайное число от 0 до 1.
    if x < P_A(tfp_n(1,t),tfp_n(1,t)) %Если x<вероятности остаться в том же состоянии, то остаемся в том же состоянии
        tfp_n(1,t+1) = tfp_n(1,t);
    else 
        tfp_n(1,t+1) = 3-tfp_n(1,t);
    end
    
    %Для труда посложнее - он определяется для каждого агента.
    x = rand(M,1); %evolution of h number; Берем случайный вектор со значениями от 0 до 1.
    ind = find(P_h(emp_n(:,t),1) > x); %В первом столбце матрицы P_h расположены вероятности того, что мы в итоге окажемся в h_нижнее. Соответсвенно,
    %номера в векторе emp_n(:,t), для которых эта вероятность больше x окажутся в итоге в состоянии h_нижнее. Запоминаем эти номера в переменную ind.
    %Далее всем задаем значение 2, а потом меняем для нормеров ind значение на 1.
    emp_n(:,t+1) = 2;
    emp_n(ind,t+1) = 1;  
end


%%%%%%%%%%%
%%% OLS %%%
%%%%%%%%%%%
t = T/10; %Т.к. мы начинаем симуляции из случайной точки, лучше пропустить первые несколько симуляций. Они будут искажать картину.
b_old = b_ols; %Запоминаем текущие значения коэффициентов регрессии, чтобы иметь возможность сравнить их с новыми.
cap = K(cap_n)'; %capital history; получаем вектор со значенями капитала по всем периодам симуляции
Y = log(cap(1,t+1:T+1))'; %log(K')
%Вспомните уравнение с семинара для динамики агрегированного капитала (в самом начале было).
X(:,1) = 2-tfp_n(1,t:T); %Первая переменная, равна 1, если A=A_нижнее
X(:,2) = X(:,1).*log(cap(1,t:T))'; %То же самое, что первая, умноженная на лог(капитал).
X(:,3) = tfp_n(1,t:T)-1; %равна 1, если A=A_верхнее
X(:,4) = X(:,3).*log(cap(1,t:T))';
Y_hat = X*b_ols; %Оцениваем уравнение по старым коэффцициентам
R_2 = corr(Y,Y_hat) %Рассчитываем R^2
b_ols = (X'*X)\(X'*Y) %Получаем новые коэффициенты
b_ols = 1/2*b_ols+1/2*b_old; %Лучше в качестве новых коэффициентов взять среднее между новыми и старыми, так сходимость будет лучше.
end %Цикл на этом закончен. Далее цикл проверит значение R^2. Если оно все еще мало, то начнет новую итерацию с новыми коэффициентами b_ols. 


%%%%%%%%%%%%%%%
%%% FIGURES %%%
%%%%%%%%%%%%%%%
plot((t:T),Y,(t:T),Y_hat)
legend('Actual capital','Expected capital')

plot((900:1000),cap(900:1000),(900:1000),tfp_n(900:1000))
legend('Capital','TFP')
toc